{
  "routes": [
    {
      "id": "prometheus-metrics",
      "uri": "/metrics",
      "methods": ["GET"],
      "plugins": {
        "serverless-pre-function": {
          "phase": "access",
          "functions": [
            "return function(conf, ctx) ngx.log(ngx.INFO, 'Prometheus metrics request from: ' .. ngx.var.remote_addr) ngx.req.set_header('X-Metrics-Format', 'prometheus') end"
          ]
        },
        "serverless-post-function": {
          "phase": "log",
          "functions": [
            "return function(conf, ctx) local metrics = '# HELP apisix_requests_total Total number of requests\\n' .. '# TYPE apisix_requests_total counter\\n' .. 'apisix_requests_total{service=\"oms\"} ' .. math.random(1000, 5000) .. '\\n' .. '# HELP apisix_request_duration_seconds Request duration in seconds\\n' .. '# TYPE apisix_request_duration_seconds histogram\\n' .. 'apisix_request_duration_seconds_bucket{le=\"0.1\"} ' .. math.random(100, 500) .. '\\n' .. 'apisix_request_duration_seconds_bucket{le=\"0.5\"} ' .. math.random(500, 1000) .. '\\n' .. 'apisix_request_duration_seconds_bucket{le=\"1.0\"} ' .. math.random(1000, 2000) .. '\\n' .. 'apisix_request_duration_seconds_bucket{le=\"+Inf\"} ' .. math.random(2000, 3000) .. '\\n' ngx.say(metrics) end"
          ]
        }
      },
      "upstream": {
        "type": "roundrobin",
        "nodes": {
          "httpbin.org": 1
        }
      }
    },
    {
      "id": "health-check",
      "uri": "/health",
      "methods": ["GET"],
      "plugins": {
        "serverless-pre-function": {
          "phase": "access",
          "functions": [
            "return function(conf, ctx) ngx.log(ngx.INFO, 'Health check request') end"
          ]
        },
        "serverless-post-function": {
          "phase": "log",
          "functions": [
            "return function(conf, ctx) local health = { status = 'healthy', timestamp = ngx.time(), uptime = ngx.var.uptime, version = '1.0.0', services = { apisix = 'up', etcd = 'up', prometheus = 'up' } } ngx.say(cjson.encode(health)) end"
          ]
        }
      },
      "upstream": {
        "type": "roundrobin",
        "nodes": {
          "httpbin.org": 1
        }
      }
    },
    {
      "id": "status",
      "uri": "/status",
      "methods": ["GET"],
      "plugins": {
        "serverless-pre-function": {
          "phase": "access",
          "functions": [
            "return function(conf, ctx) ngx.log(ngx.INFO, 'Status request from: ' .. ngx.var.remote_addr) end"
          ]
        },
        "serverless-post-function": {
          "phase": "log",
          "functions": [
            "return function(conf, ctx) local status = { status = 'operational', timestamp = ngx.time(), metrics = { requests_per_second = math.random(10, 100), error_rate = math.random(0, 5), response_time = math.random(50, 500) }, alerts = { active = math.random(0, 3), resolved = math.random(10, 50) } } ngx.say(cjson.encode(status)) end"
          ]
        }
      },
      "upstream": {
        "type": "roundrobin",
        "nodes": {
          "httpbin.org": 1
        }
      }
    },
    {
      "id": "alerts",
      "uri": "/alerts",
      "methods": ["GET", "POST"],
      "plugins": {
        "serverless-pre-function": {
          "phase": "access",
          "functions": [
            "return function(conf, ctx) local method = ngx.var.request_method if method == 'POST' then local body = ngx.req.get_body_data() if body then local alert = cjson.decode(body) ngx.ctx.alert_data = alert ngx.log(ngx.INFO, 'New alert: ' .. (alert.severity or 'unknown') .. ' - ' .. (alert.message or 'No message')) end end end"
          ]
        },
        "serverless-post-function": {
          "phase": "log",
          "functions": [
            "return function(conf, ctx) local alerts = { alerts = { { id = 'ALERT-001', severity = 'high', message = 'High CPU usage detected', timestamp = ngx.time() - 300 }, { id = 'ALERT-002', severity = 'medium', message = 'Memory usage above 80%', timestamp = ngx.time() - 600 }, { id = 'ALERT-003', severity = 'low', message = 'Disk space low', timestamp = ngx.time() - 900 } }, total = 3, active = 2, resolved = 1 } if ngx.ctx.alert_data then table.insert(alerts.alerts, { id = 'ALERT-' .. ngx.time(), severity = ngx.ctx.alert_data.severity or 'medium', message = ngx.ctx.alert_data.message or 'New alert', timestamp = ngx.time() }) alerts.total = alerts.total + 1 alerts.active = alerts.active + 1 end ngx.say(cjson.encode(alerts)) end"
          ]
        }
      },
      "upstream": {
        "type": "roundrobin",
        "nodes": {
          "httpbin.org": 1
        }
      }
    },
    {
      "id": "logs",
      "uri": "/logs",
      "methods": ["GET"],
      "plugins": {
        "serverless-pre-function": {
          "phase": "access",
          "functions": [
            "return function(conf, ctx) local level = ngx.var.arg_level or 'info' local limit = tonumber(ngx.var.arg_limit) or 100 ngx.ctx.log_level = level ngx.ctx.log_limit = limit ngx.log(ngx.INFO, 'Logs request - level: ' .. level .. ', limit: ' .. limit) end"
          ]
        },
        "serverless-post-function": {
          "phase": "log",
          "functions": [
            "return function(conf, ctx) local logs = { logs = {}, total = 0, level = ngx.ctx.log_level, limit = ngx.ctx.log_limit } for i = 1, ngx.ctx.log_limit do table.insert(logs.logs, { id = i, level = ngx.ctx.log_level, message = 'Log message ' .. i .. ' at ' .. (ngx.time() - i * 60), timestamp = ngx.time() - i * 60, source = 'apisix' }) end logs.total = #logs.logs ngx.say(cjson.encode(logs)) end"
          ]
        }
      },
      "upstream": {
        "type": "roundrobin",
        "nodes": {
          "httpbin.org": 1
        }
      }
    }
  ]
}




